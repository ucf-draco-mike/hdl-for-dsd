<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 1.1: HDL ≠ Software — Accelerated HDL for Digital System Design</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/white.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../theme/ucf-hdl.css">
    <style>
        /* Segment-specific overrides */
        .river-side-by-side {
            display: flex;
            gap: 2em;
            align-items: flex-start;
        }
        .river-side-by-side .panel {
            flex: 1;
            padding: 1em;
            border-radius: 8px;
        }
        .panel-software {
            background: #F3E5F5;
            border: 2px solid #9C27B0;
        }
        .panel-hardware {
            background: #E3F2FD;
            border: 2px solid #1565C0;
        }
        .panel h3 {
            margin-top: 0 !important;
        }
        .big-number {
            font-size: 3em;
            font-weight: 700;
            color: var(--ucf-gold);
            text-align: center;
            line-height: 1;
        }
        .big-number span {
            display: block;
            font-size: 0.25em;
            color: var(--ucf-mid-gray);
            font-weight: 400;
            margin-top: 0.3em;
        }
    </style>
</head>
<body>
<div class="reveal">
<div class="slides">

<!-- ==================== SLIDE 1: TITLE ==================== -->
<section class="title-slide" data-background-color="#000000">
    <div style="margin-bottom: 1em;">
        <span style="color: #FFC904; font-weight: 700; font-size: 0.6em; letter-spacing: 0.15em; text-transform: uppercase;">
            Accelerated HDL for Digital System Design
        </span>
    </div>
    <h1 style="color: #FFC904; border-bottom: none; font-size: 2.2em;">
        HDL ≠ Software
    </h1>
    <p class="subtitle" style="color: #E8E8E4;">
        Day 1, Video 1 of 4 &nbsp;·&nbsp; ~12 minutes
    </p>
    <p class="course-info" style="color: #888;">
        UCF College of Engineering &amp; Computer Science<br>
        Department of Electrical &amp; Computer Engineering
    </p>
    <aside class="notes">
        Welcome to the first video in the Accelerated HDL for Digital System Design course.
        This is Video 1 of 4 for Day 1. It's about 12 minutes long.
        This video tackles the single most important concept you need to internalize
        before you write your first line of Verilog.
    </aside>
</section>

<!-- ==================== SLIDE 2: THE HOOK ==================== -->
<section>
    <h2>The #1 Mistake New HDL Designers Make</h2>
    <p style="font-size: 1.1em; margin-top: 1em;">
        If you know C, Python, or Java, your instinct will be to read Verilog top-to-bottom
        and imagine it executing <strong>line by line</strong>.
    </p>
    <div class="callout-danger" style="margin-top: 1em;">
        <strong>This instinct is wrong.</strong><br>
        Unlearning it is the single most important thing you'll do in the first week.
    </div>
    <aside class="notes">
        Let's start with the most important thing I can tell you in this entire course.
        If you've programmed in C, Python, Java, or really any programming language,
        you have a deeply ingrained instinct: code executes top to bottom, one line at a time.
        That instinct is wrong in Verilog. It will mislead you. And unlearning it is
        the single most important thing you'll do this week.
    </aside>
</section>

<!-- ==================== SLIDE 3: SIDE-BY-SIDE CODE ==================== -->
<section>
    <h2>The Same Syntax, Completely Different Meaning</h2>
    <div class="river-side-by-side" style="margin-top: 0.5em;">
        <div class="panel panel-software">
            <h3 style="color: #7B1FA2;">Software (C)</h3>
            <pre class="synth"><code class="language-c" data-noescape>a = b + c;
d = a * 2;</code></pre>
            <p style="font-size: 0.65em;" class="fragment" data-fragment-index="1">
                Line 1 executes, completes, <em>then</em> line 2 executes.
                One ALU. Sequential.
            </p>
        </div>
        <div class="panel panel-hardware">
            <h3 style="color: #1565C0;">Hardware (Verilog)</h3>
            <pre class="synth"><code class="language-verilog" data-noescape>assign a = b + c;
assign d = a * 2;</code></pre>
            <p style="font-size: 0.65em;" class="fragment" data-fragment-index="1">
                Both exist <strong>simultaneously</strong>.
                An adder AND a multiplier, always active.
            </p>
        </div>
    </div>
    <div class="fragment callout" data-fragment-index="2" style="margin-top: 0.5em;">
        When <code>b</code> or <code>c</code> change, <code>a</code> changes,
        and <code>d</code> changes — all propagating through physical gates.
    </div>
    <aside class="notes">
        Let's look at two snippets that look almost identical but mean completely different things.
        On the left: C code. a equals b plus c, then d equals a times 2.
        Line 1 runs on the CPU, finishes, stores the result, then line 2 runs. Sequential.
        On the right: Verilog. These two assign statements describe hardware that
        exists simultaneously. There is an adder producing a, and there is a multiplier
        producing d, and they are BOTH always active.
        When b or c changes, a changes, and d changes — all propagating through
        physical gates with real propagation delays. No sequencing. No program counter.
    </aside>
</section>

<!-- ==================== SLIDE 4: THREE DIFFERENCES TABLE ==================== -->
<section>
    <h2>Three Fundamental Differences</h2>
    <table style="margin-top: 0.5em;">
        <thead>
            <tr>
                <th style="width: 25%;">Concept</th>
                <th style="width: 37%;">Software</th>
                <th style="width: 38%;">Hardware (Verilog)</th>
            </tr>
        </thead>
        <tbody>
            <tr class="fragment">
                <td><strong>Execution</strong></td>
                <td>Sequential — one instruction at a time</td>
                <td>Concurrent — all hardware operates simultaneously</td>
            </tr>
            <tr class="fragment">
                <td><strong>Assignment</strong></td>
                <td>"Compute and store in variable"</td>
                <td>"Create a permanent physical connection"</td>
            </tr>
            <tr class="fragment">
                <td><strong>Time</strong></td>
                <td>Implicit — program counter advances</td>
                <td>Explicit — propagation delay; clock edges</td>
            </tr>
        </tbody>
    </table>
    <aside class="notes">
        Let me give you three fundamental differences to anchor this.
        First: execution model. Software is sequential — one instruction at a time.
        Hardware is concurrent — everything operates simultaneously.
        Second: what assignment means. In software, it means compute a value and store it.
        In hardware, it means create a permanent physical connection — like soldering a wire.
        Third: time. In software, time is implicit — the program counter advances.
        In hardware, time is explicit — signals propagate with real physical delay,
        and clock edges define when things happen.
        These three differences will come up again and again throughout this course.
    </aside>
</section>

<!-- ==================== SLIDE 5: THE RIVER ANALOGY ==================== -->
<section data-background-color="#FAFAFA">
    <h2>The River Analogy</h2>
    <div class="river-side-by-side" style="margin-top: 1em;">
        <div class="panel" style="background: #FFF; border: 1px solid #DDD; text-align: center;">
            <h3 style="color: #7B1FA2;">Software = Recipe</h3>
            <p style="font-size: 0.75em;">
                Do step 1<br>
                ↓<br>
                Then step 2<br>
                ↓<br>
                Then step 3
            </p>
            <p style="font-size: 0.6em; color: #888;">Sequential. Ordered. One thing at a time.</p>
        </div>
        <div class="panel" style="background: #FFF; border: 1px solid #DDD; text-align: center;">
            <h3 style="color: #1565C0;">Hardware = River System</h3>
            <p style="font-size: 0.75em;">
                Water flows through<br>
                <strong>ALL tributaries</strong><br>
                simultaneously
            </p>
            <p style="font-size: 0.6em; color: #888;">Add a dam here → affects flow there. Everything at once.</p>
        </div>
    </div>
    <div class="fragment golden-rule" style="margin-top: 1em;">
        You are not writing instructions.<br>
        You are describing the geography of the river.
    </div>
    <aside class="notes">
        Here's an analogy that will carry you through the entire first week.
        Software is like following a recipe: do step 1, then step 2, then step 3. Sequential.
        Hardware is like a river system. Water flows through ALL tributaries simultaneously.
        If you add a dam here, it affects the flow over there. Everything is happening at once.
        [PAUSE — let this sink in]
        You are not writing instructions. You are describing the geography of the river.
        When you're confused about why Verilog behaves a certain way, come back to this analogy.
    </aside>
</section>

<!-- ==================== SLIDE 6: RESOURCE MAPPING ==================== -->
<section>
    <h2>More Code = More Hardware</h2>
    <div class="columns">
        <div class="col">
            <h3>Software</h3>
            <pre><code class="language-c" data-noescape>x = a + b;
y = c + d;</code></pre>
            <p style="font-size: 0.7em;" class="fragment" data-fragment-index="1">
                May reuse the <strong>same CPU adder</strong> at different times.
            </p>
        </div>
        <div class="col">
            <h3>Verilog</h3>
            <pre class="synth"><code class="language-verilog" data-noescape>assign x = a + b;
assign y = c + d;</code></pre>
            <p style="font-size: 0.7em;" class="fragment" data-fragment-index="1">
                Each implies its <strong>own physical adder</strong>.
                Two adders exist on the chip.
            </p>
        </div>
    </div>
    <div class="fragment callout-warning" data-fragment-index="2" style="margin-top: 0.5em; font-size: 0.8em;">
        <strong>Resource awareness:</strong> More lines of Verilog = more gates = more FPGA resources consumed.
        You cannot <code>malloc</code> a flip-flop. Everything is fixed at synthesis time.
    </div>
    <aside class="notes">
        Here's another critical difference. In software, x equals a plus b and y equals c plus d
        may reuse the same physical adder in the CPU at different times.
        The CPU has a fixed number of ALUs and it time-shares them.
        In Verilog, each assign statement with an addition implies its OWN physical adder.
        Two additions means two adders exist on the chip simultaneously.
        This means more lines of Verilog equals more hardware, more gates, more FPGA resources consumed.
        You cannot malloc a flip-flop. There's no dynamic memory allocation.
        All hardware resources are fixed at synthesis time and do not change at runtime.
    </aside>
</section>

<!-- ==================== SLIDE 7: PARALLELISM IS FREE ==================== -->
<section>
    <h2>Parallelism: Software vs. Hardware</h2>
    <div class="columns" style="margin-top: 1em;">
        <div class="col" style="text-align: center;">
            <div class="big-number" style="color: #C62828;">Hard</div>
            <p style="font-size: 0.7em; margin-top: 0.5em;">
                <strong>Software parallelism</strong><br>
                Threads, locks, synchronization,<br>race conditions, deadlocks…
            </p>
        </div>
        <div class="col" style="text-align: center;">
            <div class="big-number" style="color: var(--color-synth);">Free</div>
            <p style="font-size: 0.7em; margin-top: 0.5em;">
                <strong>Hardware parallelism</strong><br>
                Every <code>assign</code> runs simultaneously.<br>
                Parallelism is the <em>default</em>.
            </p>
        </div>
    </div>
    <p class="fragment" style="text-align: center; font-size: 0.8em; margin-top: 1em; color: var(--ucf-mid-gray);">
        In hardware, you have to work <em>harder</em> to make things sequential.
    </p>
    <aside class="notes">
        This flips something you probably take for granted.
        In software, parallelism is HARD. You need threads, locks, synchronization primitives,
        and you still get race conditions and deadlocks. It's an entire course in itself.
        In hardware, parallelism is FREE. Every assign statement runs simultaneously.
        Parallelism is the default. You actually have to work harder to make things sequential.
        This is one of the great strengths of hardware design — and it's why FPGAs and ASICs
        can process data so much faster than CPUs for certain workloads.
    </aside>
</section>

<!-- ==================== SLIDE 8: RECAP / KEY TAKEAWAYS ==================== -->
<section>
    <h2>Key Takeaways</h2>
    <div style="margin-top: 0.5em;">
        <p class="fragment" style="font-size: 0.85em;">
            <span style="color: var(--ucf-gold); font-size: 1.3em; font-weight: 700;">①</span>&ensp;
            Verilog describes <strong>concurrent hardware</strong>, not sequential instructions.
        </p>
        <p class="fragment" style="font-size: 0.85em;">
            <span style="color: var(--ucf-gold); font-size: 1.3em; font-weight: 700;">②</span>&ensp;
            <code>assign</code> creates a permanent connection — a wire, not a variable.
        </p>
        <p class="fragment" style="font-size: 0.85em;">
            <span style="color: var(--ucf-gold); font-size: 1.3em; font-weight: 700;">③</span>&ensp;
            More Verilog = more hardware. Resources are fixed at synthesis time.
        </p>
        <p class="fragment" style="font-size: 0.85em;">
            <span style="color: var(--ucf-gold); font-size: 1.3em; font-weight: 700;">④</span>&ensp;
            Parallelism is free. Sequentiality takes effort.
        </p>
    </div>
    <div class="fragment golden-rule" style="margin-top: 1em;">
        You are describing the geography of the river — not writing a recipe.
    </div>
    <aside class="notes">
        Let me recap the key points from this video.
        One: Verilog describes concurrent hardware, not sequential instructions.
        Two: assign creates a permanent connection — think of it as a wire, not a variable.
        Three: More Verilog means more hardware. Resources are fixed at synthesis time.
        Four: Parallelism is free. Sequentiality is what takes effort.
        Remember: you are describing the geography of the river, not writing a recipe.
        In the next video, we'll look at the two tools that consume your Verilog code:
        synthesis and simulation. They do very different things with the same source file.
    </aside>
</section>

<!-- ==================== SLIDE 9: NEXT VIDEO BRIDGE ==================== -->
<section data-background-color="#000000">
    <div style="text-align: center;">
        <p style="color: #FFC904; font-size: 0.7em; font-weight: 600; letter-spacing: 0.1em; text-transform: uppercase;">
            Up Next
        </p>
        <h2 style="color: #FFFFFF; font-size: 1.8em;">Synthesis vs. Simulation</h2>
        <p style="color: #E8E8E4; font-size: 0.8em; margin-top: 0.5em;">
            Day 1, Video 2 of 4 &nbsp;·&nbsp; ~10 minutes
        </p>
        <p style="color: #888; font-size: 0.6em; margin-top: 2em;">
            The same Verilog file, two very different tools, two very different purposes.
        </p>
    </div>
    <aside class="notes">
        That's the end of Video 1. Next up: Synthesis versus Simulation.
        The same Verilog file gets consumed by two very different tools
        that do two very different things. Understanding this distinction is critical
        before you write your first design. See you in the next video.
    </aside>
</section>

</div><!-- /slides -->
</div><!-- /reveal -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
<script>
Reveal.initialize({
    hash: true,
    slideNumber: 'c/t',
    showSlideNumber: 'all',
    width: 1280,
    height: 720,
    margin: 0.04,
    transition: 'slide',
    transitionSpeed: 'default',
    backgroundTransition: 'fade',
    plugins: [ RevealHighlight, RevealNotes ],
    // Presenter view: press 'S' to open speaker notes
});
</script>
</body>
</html>
